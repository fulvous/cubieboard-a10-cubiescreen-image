#!/bin/bash

#Cubiecopiadora realiza imagenes para memoria SD para cubieboard A10
#Copyright (C) 2017 Leon Ramos @fulvous
#
#Este archivo es parte de Cubiecopiadora
#
#Cubiecopiadora es software libre: Puede redistribuirlo y/o 
#modificarlo bajo los terminos de la Licencia de uso publico 
#general GNU de la Fundacion de software libre, ya sea la
#version 3 o superior de la licencia.
#
#Cubiecopiadora es distribuida con la esperanza de que sera util,
#pero sin ningun tipo de garantia; inclusive sin la garantia
#implicita de comercializacion o para un uso particular.
#Vea la licencia de uso publico general GNU para mas detalles.
#
#Deberia de recibir uan copia de la licencia de uso publico
#general junto con Cubiecopiadora, de lo contrario, vea
#<http://www.gnu.org/licenses/>.
#
#This file is part of Cubiecopiadora
#
#Cubiecopiadora is free software: you can redistribute it and/or 
#modify it under the terms of the GNU General Public License 
#as published by the Free Software Foundation, either version 3 
#of the License, or any later version.
#
#Cubiecopiadora is distributed in the hope that it will be useful,
#but WITHOUT ANY WARRANTY; without even the implied warranty of
#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#GNU General Public License for more details.
#
#You should have received a copy of the GNU General Public License
#along with Cubiecopiadora  If not, see 
#<http://www.gnu.org/licenses/>.

source herramientax/herramientax

#Evita que se ejecute el programa si hay errores
set -e

PWD_F="$(pwd)"

#Valores de ejecucion
VERBOSE=0
BORRAR=0
UBOOT_C=1
KERNEL_C=1
KERNEL_P=1
IMAGEN_C=1
DEBOOTSTRAP_C=1
DEBOOTSTRAP_G=0
LOG="${PWD_F}/cubiecopiadora.log"

#Locales
export LANG=C
export LC_ALL=C

#Folders
KERNEL_F="linux-sunxi"
UBOOT_F="u-boot-sunxi"
SALIDA_F="salida"
TMP_F="tmp"
DEBOOTSTRAP_F="sistemas"
FOLDERS="${KERNEL_F} ${UBOOT_F} ${SALIDA_F} ${TMP_F} ${DEBOOTSTRAP_F}"


#Valores para compilacion
TARJETA="Cubieboard"
CONFIG_TARJETA="sun4i_defconfig"
KERNEL_V="3.4.79"
UBOOT_V="sunxi"

#Valores para la imagen
DISTRO="wheezy"
MNT="mnt"
IMAGEN="${TARJETA}-${KERNEL_V}-$(date +%Y%m%d).img"

DEBOOTSTRAP_I=${DISTRO}-db
DEBOOTSTRAP_EXT="tar.gz"
PAQUETES_DB="sudo,vim"

case ${DISTRO} in
  wheezy)
    PAQUETES_DB="${PAQUETES_DB},wpasupplicant,wireless-tools,i2c-tools"
    ;;
esac

#Checando si es superusuario
es_root

function uso {
  jumbotron \
  "${BLANCO}$0${AMARILLO} soporta estas opciones:" \
  "  -g          Hacer imagen grafica." \
  "  -i          NO crear imagen SD." \
  "  -k          NO compiles kernel." \
  "  -p          NO ejecutes ${CYAN}include/patch.sh${RESET}." \
  "  -u          NO compiles u-boot." \
  "  -r          Borra todos los directorios." \
  "  -v          Muestra informacion adicional." \
  "  -h          Imprime esta ayuda." 
}

while getopts gkpurvh OPT ; do
  case $OPT in
    g)
      DEBOOTSTRAP_G=1
      DEBOOTSTRAP_I=${DISTRO}-db-g
      ;;
    i)
      IMAGEN_C=0
      ;;
    k)
      KERNEL_C=0
      ;;
    p)
      KERNEL_P=0
      ;;
    u)
      UBOOT_C=0
      ;;
    r)
      BORRAR=1
      ;;
    v)
      VERBOSE=1
      ;;
    h)
      uso
      exit 0
      ;;
    \?)
      res_err "Opcion invalida" "$OPTARG" "ERROR"
      uso
      exit 1
      ;;
  esac
done

#Checando configuraciones adicionales
if [ -f ${PWD_F}/include/configs.sh ] ; then
  informa "Cargando configuraciones" "${PWD_F}/include/configs.sh"
  source ${PWD_F}/include/configs.sh
  res_ok "Cargadas configuraciones" "${PWD_F}/include/configs.sh" "Exitoso"
fi

#Instalando paquetes necesarios
informa "Instalando" "Paquetes" "necesarios"
apt-get install -y \
  qemu binfmt-support qemu-user-static \
  gcc-arm-linux-gnueabihf pigz debootstrap \
  kpartx
res_ok "Paquetes" "instalados" "Exitoso"

#Borrar carpetas
if [ "${BORRAR}" == "1" ] ; then
  informa "Borrando" "carpetas" "todas"
  for folder in ${FOLDERS} ; do
    if [ -d ${PWD_F}/${folder} ] ; then
      debug "Borrando ${PWD_F}/$folder"
      rm -Rf ${PWD_F}/${folder}
    fi
  done
  res_ok "Carpetas borradas" "todas" "Exitoso"
  debug "Activando compilacion de u-boot y kernel"
  UBOOT_C=1
  KERNEL_C=1
fi

#Descargando u-boot
if [ ! -d ${UBOOT_F} ] ; then
  informa "Descargando" "u-boot" "${UBOOT_V}"
  git clone -b ${UBOOT_V} https://github.com/linux-sunxi/u-boot-sunxi.git ${UBOOT_F}
  res_ok "Descarga" "u-boot-${UBOOT_V}" "Exitoso"
else
  informa "Actualizando" "u-boot" "${UBOOT_V}"
  cd ${UBOOT_F}
  git pull
  cd ${PWD_F}
fi

#Descargando kernel
if [ ! -d ${KERNEL_F} ] ; then
  informa "Descargando" "kernel" "${KERNEL_V}"
  git clone -b sunxi-${KERNEL_V} https://github.com/linux-sunxi/linux-sunxi.git ${KERNEL_F}
  res_ok "Descarga" "kernel-${KERNEL_V}" "Exitoso"
else
  informa "Actualizando" "kernel" "${KERNEL_V}"
  cd ${KERNEL_F}
  git stash
  git pull https://github.com/linux-sunxi/linux-sunxi.git 
  cd ${PWD_F}
fi

#Preparando folders temporales y de salida
informa "Validando" "folders" "${OUTPUT_F} ${TMP_F}"
for folder in "${OUTPUT_F} ${TMP_f}"; do
  [ ! -d ${PWD_F}/${folder} ] && \
  debug "Creando folder ${PWD_F}/${folder}" && \
  mkdir ${PWD_F}/${folder}
done
rm -Rfv ${PWD_F}/${TMP_F}/*
res_ok "Folders existentes" "${OUTPUT_F} ${TMP_F}" "Exitoso"

#Compilando u-boot
if [ "${UBOOT_C}" == "1" ] ; then
  informa "Configurando" "u-boot" "${TARJETA}_config"
  cd ${PWD_F}/${UBOOT_F}
  make -j$(nproc) CROSS_COMPILE=arm-linux-gnueabihf- ${TARJETA}_config
  informa "Compilando" "u-boot" "${TARJETA}"
  make -j$(nproc) CROSS_COMPILE=arm-linux-gnueabihf- 
  informa "Generando" "script.bin" "${TARJETA}"
  cd ${PWD_F}
  [ ! -d ${PWD_F}/${DEBOOTSTRAP_F}/${UBOOT_V} ] && \
    mkdir -p ${PWD_F}/${DEBOOTSTRAP_F}/${UBOOT_V}
  fex2bin ${PWD_F}/sources/fex/script.fex \
  ${PWD_F}/${DEBOOTSTRAP_F}/${UBOOT_V}/script.bin
  res_ok "Compilacion de" "u-boot-${UBOOT_V}" "Exitoso"
fi

#Configuración y compilado del kernel
if [ "${KERNEL_C}" == "1" ] ; then

  informa "Configurando" "kernel" "${KERNEL_V}"

  cd ${PWD_F}/${KERNEL_F}

  make -j$(nproc) ARCH=arm \
  CROSS_COMPILE=arm-linux-gnueabihf- \
  ${CONFIG_TARJETA}

  if [ "${KERNEL_P}" == "1" ] ; then
    informa "Ejecutando" "kernel" "patch.sh"
    cd ${PWD_F}
    [ ! -d ${PWD_F}/${TMP_F} ] && \
      mkdir -p ${PWD_F}/${TMP_F}
    source include/patch.sh
    sleep 3
  fi

  informa "Compilando" "kernel" "${KERNEL_V}"

  cd ${PWD_F}/${KERNEL_F}

  make -j$(nproc) ARCH=arm \
  CROSS_COMPILE=arm-linux-gnueabihf- \
  uImage modules

  informa "Instalando" "modulos" "${KERNEL_V}"

  [ ! -d ${PWD_F}/${DEBOOTSTRAP_F}/${KERNEL_V} ] && \
    mkdir -p ${PWD_F}/${DEBOOTSTRAP_F}/${KERNEL_V}

  make ARCH=arm \
  CROSS_COMPILE=arm-linux-gnueabihf- \
  INSTALL_MOD_PATH=${PWD_F}/${DEBOOTSTRAP_F}/${KERNEL_V} \
  modules_install
  
  cd ${PWD_F}

  res_ok "Compilacion" "kernel-${KERNEL_V}" "Exitoso"
fi

jumbotron "Proceso de compilación terminado" \
  "Continuando con creación de imagen" \
  "Se descargara el sistema de archivos si no existe"


### Continuando con el proceso de creacion de imagen
if [ "$IMAGEN_C" == "1" ] ; then
  informa "Generando imagen" "uSD" "${IMAGEN}"
  
  if [ ! -d ${DEBOOTSTRAP_F} ] ; then
    debug "No existe la carpeta ${DEBOOTSTRAP_F} generandola..."
    mkdir ${PWD_F}/${DEBOOTSTRAP_F}
    debug "Marcando debootstrap para su creacion"
    DEBOOTSTRAP_C=1
  fi

  if [ "${DEBOOTSTRAP_C}" == "1" ] ; then
    informa "Creando imagen" "Debootstrap" "${DEBOOTSTRAP_I}"
    if [ ! -f ${PWD_F}/${DEBOOTSTRAP_F}/${DEBOOTSTRAP_I}.${DEBOOTSTRAP_EXT} ] ; then
      debug "No existe imagen debootstrap, hay que crearla"
      [ -d ${PWD_F}/${DEBOOTSTRAP_F}/${DEBOOTSTRAP_I} ] && \
        informa "Borrando directorio incompleto" \
          ${PWD_F}/${DEBOOTSTRAP_F}/${DEBOOTSTRAP_I} && \
        rm -Rf ${PWD_F}/${DEBOOTSTRAP_F}/${DEBOOTSTRAP_I}
      debug "Creando el directorio ${PWD_F}/${DEBOOTSTRAP_F}/${DEBOOTSTRAP_I}"
      mkdir ${PWD_F}/${DEBOOTSTRAP_F}/${DEBOOTSTRAP_I}
      informa "Descargando" "paquetes" "${DISTRO}"

      if [ "${DEBOOTSTRAP_G}" == "1" ] ; then
        case ${DISTRO} in
          "wheezy")
            PAQUETES_DB="${PAQUETES_DB},task-lxde-desktop,openbox-themes,gnome-icon-theme,libgdk-pixbuf2.0-dev,pixmap,network-manager-gnome,gtk2-engines-pixbuf,ruby-gdk-pixbuf2"
            debug "Agregando lxde a paquetes: ${PAQUETES_DB}"
            echo "[ -f /tmp/inicial.sh ] && /tmp/inicial.sh" >> /etc/rc.local
        

cat <<EOT > /tmp/inicial.sh
/usr/lib/arm-linux-gnueabihf/gdk-pixbuf-2.0/gdk-pixbufuery-loaders > /usr/lib/arm-linux-gnueabihf/gdk-pixbuf-2.0/2.10.0/loaders.cache
rm /tmp/inicial.sh
EOT

            chmod 755 /tmp/inicial.sh


            ;;
        esac
      fi
      debug "Corriendo el debootstrap"
      LANG=C debootstrap --include="${PAQUETES_DB}" \
      --arch=armhf \
      --foreign ${DISTRO} \
      ${PWD_F}/${DEBOOTSTRAP_F}/${DEBOOTSTRAP_I}

      cp /usr/bin/qemu-arm-static \
        ${PWD_F}/${DEBOOTSTRAP_F}/${DEBOOTSTRAP_I}/usr/bin
      LANG=C chroot ${PWD_F}/${DEBOOTSTRAP_F}/${DEBOOTSTRAP_I} \
        /usr/bin/qemu-arm-static /bin/sh \
        -i /debootstrap/debootstrap --second-stage
      informa "Comprimiendo debootstrap" "${DISTRO}" "${DEBOOTSTRAP_I}.${DEBOOTSTRAP_EXT}"
      cd ${PWD_F}/${DEBOOTSTRAP_F}
      tar cf - ${DEBOOTSTRAP_I} | \
        pigz -9 > ${DEBOOTSTRAP_I}.${DEBOOTSTRAP_EXT} 
      cd ${PWD_F}
      debug "Borrando el directorio de trabajo"
      rm -Rf ${PWD_F}/${DEBOOTSTRAP_F}/${DEBOOTSTRAP_I}
    else
      informa "Imagen" "${DEBOOTSTRAP_I}" "Encontrada"
    fi
    res_ok "Debootstrap" "creado" "Exitoso"
  fi

  informa "Creando" "archivo" "temporal"
  dd if=/dev/zero \
    of=${PWD_F}/${TMP_F}/${IMAGEN} \
    bs=1G count=3
  res_ok "Archivo" "${PWD_F}/${TMP_F}/${IMAGEN}" "Exitoso"

  #Creando dispositivo loop
  debug "Asignando loop"
  LOOP="$(losetup -f)"
  informa "Asignando" "loop" "${LOOP}"
  losetup ${LOOP} ${PWD_F}/${TMP_F}/${IMAGEN}

  #Instalando boot
  informa "Instalando" "u-boot"
  dd if=${PWD_F}/${UBOOT_F}/u-boot-sunxi-with-spl.bin \
    of=${LOOP} \
    bs=1024 \
    seek=8
  res_ok "U-boot" "instalado" "Exitoso"

  #Particionando loop
  informa "Particionando" "${LOOP}"
  sfdisk -R ${LOOP}
cat <<EOT | sfdisk --in-order -L -uM ${LOOP}
1,16,c
,,L
EOT
  res_ok "Dispositivo" "particionado" "Exitoso"
  
  #Desinstalando loop
  informa "Desmontando" "loop" "${LOOP}"
  losetup -d ${LOOP}
  res_ok "Loop" "desmontado" "Exitoso"

  #Montando con kpartx
  informa "Montando con" "kpartx" "${TMP_F}/${IMAGEN}"
  parts=($(kpartx -l ${PWD_F}/${TMP_F}/${IMAGEN} | egrep -o "loop[0-9]{1,2}p[0-9]{1,2}"))
  kpartx -av ${PWD_F}/${TMP_F}/${IMAGEN}

  #Formateando particiones
  informa "Formateando" "particion" "${parts[0]}"
  mkfs.vfat /dev/mapper/${parts[0]}
  res_ok "Particionada" "${parts[0]}" "Exitoso"
  informa "Formateando" "particion" "${parts[1]}"
  mkfs.ext4 /dev/mapper/${parts[1]}
  res_ok "Particionada" "${parts[1]}" "Exitoso"

  #Copiando particion boot
  informa "Copiando" "particion" "boot"
  if [ ! -d ${PWD_F}/${TMP_F}/${MNT} ] ; then
    debug "No existe la carpeta boot, creandola"
    mkdir -p ${PWD_F}/${TMP_F}/${MNT}
  fi
  mount /dev/mapper/${parts[0]} ${PWD_F}/${TMP_F}/${MNT}
  cp -v ${PWD_F}/${KERNEL_F}/arch/arm/boot/uImage \
    ${PWD_F}/${TMP_F}/${MNT}
  [ ! -d ${PWD_F}/${DEBOOTSTRAP_F}/${UBOOT_V} ] && \
    mkdir -p ${PWD_F}/${DEBOOTSTRAP_F}
  cp -v ${PWD_F}/${DEBOOTSTRAP_F}/${UBOOT_V}/script.bin \
    ${PWD_F}/${TMP_F}/${MNT}
  umount /dev/mapper/${parts[0]}

  #Copiando particion root
  informa "Copiando" "Root"
  mount /dev/mapper/${parts[1]} ${PWD_F}/${TMP_F}/${MNT}
  debug "Descomprimiendo con pigz"
  cd ${PWD_F}/${TMP_F}/${MNT} 
  pigz -dc ${PWD_F}/${DEBOOTSTRAP_F}/${DEBOOTSTRAP_I}.${DEBOOTSTRAP_EXT} \
    | tar xf - --strip 1
  cd ${PWD_F}
  res_ok "Archivos descomprimidos en" "root" "Exitoso"
  informa "Copiando" "modulos"
  if [ ! -d ${PWD_F}/${TMP_F}/${MNT}/lib/modules ] ; then
    debug "Creando directorio ${PWD_F}/${TMP_F}/${MNT}/lib/modules"
    mkdir -p ${PWD_F}/${TMP_F}/${MNT}/lib/modules
  fi
  cp -vr ${PWD_F}/${DEBOOTSTRAP_F}/${KERNEL_V}/lib ${PWD_F}/${TMP_F}/${MNT}
  res_ok "Copia de modulos" "${KERNEL_V}" "Exitoso"

  #Creando sources.list
  informa "Agregando" "sources.list"
cat <<EOT > ${PWD_F}/${TMP_F}/${MNT}/etc/apt/sources.list
deb http://http.debian.net/debian $DISTRO main contrib non-free
deb-src http://http.debian.net/debian $DISTRO main contrib non-free
deb http://http.debian.net/debian $DISTRO-updates main contrib non-free
deb-src http://http.debian.net/debian $DISTRO-updates main contrib non-free
deb http://security.debian.org/debian-security $DISTRO/updates main contrib non-free
deb-src http://security.debian.org/debian-security $DISTRO/updates main contrib non-free
EOT
  res_ok "Archivo" "Sources.list" "Exitoso"
  
  #Agregando entradas a fstab
  informa "Agregando" "/etc/fstab"
cat <<EOT >> ${PWD_F}/${TMP_F}/${MNT}/etc/fstab
none  /tmp  tmpfs defaults,noatime,mode=1777 0 0
/dev/mmcblk0p1 /boot vfat  defaults  0 0
EOT
  res_ok "Archivo cambiado" "/etc/fstab" "Exitoso"

  #Agregando archivo de interfaces
  informa "Agregando" "/etc/network/interfaces"
cat <<EOT > ${PWD_F}/${TMP_F}/${MNT}/etc/network/interfaces
auto lo
iface lo inet loopback
allow-hotplug eth0
iface eth0 inet dhcp
EOT
  res_ok "Archivo creado" "/etc/network/interfaces" "Exitoso"

  #Agregando archivo resolv.conf
  informa "Agregando" "/etc/resolv.conf"
cat <<EOT > ${PWD_F}/${TMP_F}/${MNT}/etc/resolv.conf
nameserver 8.8.8.8
nameserver 4.2.2.2
EOT
  res_ok "Archivo creado" "/etc/resolv.conf" "Exitoso"

  #Montando fs virtuales
  informa "Montando carpetas" "proc dev dev/pts sys"
  for i in proc dev sys; do
    mount -o bind /$i ${PWD_F}/${TMP_F}/${MNT}/$i
  done
  mount -o bind /dev/pts ${PWD_F}/${TMP_F}/${MNT}/dev/pts
  res_ok "Carpetas montadas" "proc dev dev/pts sys" "Exitoso"

  #Actualizar paquetes
  informa "Actualizando" "paquetes"
  debug "Creando tmp/update.sh"
cat <<EOT > ${PWD_F}/${TMP_F}/${MNT}/tmp/update.sh
#!/bin/bash
apt-get update -y
apt-get upgrade -y
EOT
  debug "Ejecutando tmp/update.sh"
  LANG=C chroot ${PWD_F}/${TMP_F}/${MNT} \
    /usr/bin/qemu-arm-static /bin/bash \
    /tmp/update.sh
  debug "Borrando archivo de actualizacion"
  rm ${PWD_F}/${TMP_F}/${MNT}/tmp/update.sh
  res_ok "Actualizacion de" "sistema" "Exitoso"

  #Evitar actualizaciones automaticas
  informa "Evitar actualizaciones" "automaticas"
cat <<EOT > ${PWD_F}/${TMP_F}/${MNT}/etc/apt/apt.conf.d/71-no-recommends
APT::Install-Recommends "0";
APT::Install-Suggests "0";
EOT
  res_ok "Actualizaciones automaticas" "/etc/apt/apt.conf.d/71-no-recommends" "Exitoso"

  #Asegurarnos de tener terminal serial
  informa "Habilitar" "terminal serial"
  echo "T0:2345:respawn:/sbin/getty -L ttyS0 115200 vt100" >> ${PWD_F}/${TMP_F}/${MNT}/etc/inittab

  #Ejecutando los scripts custom
  informa "Ejecutando" "include/custom.sh"
  debug "Copiando los scripts a la imagen"
  cp -v ${PWD_F}/herramientax/formato/colores.sh \
    ${PWD_F}/${TMP_F}/${MNT}
  cp -v ${PWD_F}/include/custom.sh \
    ${PWD_F}/${TMP_F}/${MNT}

  debug "Ejecutando el script en jaula"
  LANG=C chroot ${PWD_F}/${TMP_F}/${MNT} \
    /usr/bin/qemu-arm-static /bin/bash \
    /custom.sh
  
  debug "Borrando los scripts de la imagen"
  rm ${PWD_F}/${TMP_F}/${MNT}/custom.sh
  rm ${PWD_F}/${TMP_F}/${MNT}/colores.sh
  
  res_ok "Script" "include/custom.sh" "Exitoso"
  
  informa "Desmontando" "sistemas de archivos"
  #Desmontando systemas de archivos
  sleep 3
  debug "Desmontando sistemas virtuales"
  umount ${PWD_F}/${TMP_F}/${MNT}/dev/pts
  for i in proc dev sys; do
    umount ${PWD_F}/${TMP_F}/${MNT}/$i
  done
  sleep 3
  umount /dev/mapper/${parts[1]}

  #Desmontando con kpartx
  debug "Desmontando particiones loop"
  kpartx -d ${PWD_F}/${TMP_F}/${IMAGEN}
  res_ok "Particion desmontada" "${PWD_F}/${TMP_F}/${IMAGEN}" "Exitoso"

  #Moviendo la imagen a la carpeta de salida
  if [ ! -d ${PWD_F}/${SALIDA_F} ] ; then
    informa "Creando la carpeta de salida" "${PWD_F}/${SALIDA_F}"
    mkdir -p ${PWD_F}/${SALIDA_F}
  fi
  informa "Moviendo imagen de folder temporal a" "salida" 
  cp -v ${PWD_F}/${TMP_F}/${IMAGEN}  \
    ${PWD_F}/${SALIDA_F}
  res_ok "Imagen ${IMAGEN} copiada a" "${PWD_F}/${SALIDA_F}" "Exitoso"

fi

